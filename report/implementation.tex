\chapter{Implementation}
This chapter will describe my implementation of the procedural road generation algorithm, how the roads produced here is integrated with the snow simulator with all the changes to the snow simulator this entails, and lastly it describes the details about my implementation of the USGS DEM to height map converter application.

\section{Procedural road generation}
For this project, I implemented the road generation algorithm described by \cite{roadgen} for generating a road through a terrain described by a discrete height map. The road generator is a separate program written in C++ implementing an A* search algorithm which takes in a terrain in form of a heightmap, and outputs a file in the RoadXML format (see \cite{roadxml}). This section will first present the particular A* implementation, then it will describe how the clothoid spline is generated. Lastly, the RoadXML export code is described.

\subsection{Implementation of A*}
An A* search often has a very large amount of insertion operations to the $OPEN$ set, as it is used in algorithm \ref{alg:astar}. In addition, every iteration the node with the lowest $f$-cost must be retrieved from this set. Using an unsorted list gives a constant insertion time, but a really bad lookup-time when searching for the node with the lowest $f$-cost of $O(n)$. In the other extreme, a sorted list gives constant lookup-time, but insertion takes $O(n)$ time. 

Instead, typically a min-heap is used. A min-heap has a constant lookup-time because the next element to be extracted is always on top, but in addition the element must be removed, which takes $O(lg n)$ time. Insertion takes in theory $O(lg(n))$ time, but due to the structure of the heap, in reality this cost is constant. In this implementation, a min-heap is used. 

\subsubsection{Neighborhood mask creation}
A typical A* implementation for use with a grid like the discretization of a terrain often use eight neighbors. \cite{roadgen} propose that not only the immediate eight neighbors are used per node, but instead use a larger neighborhood as described in section \ref{sec:roadgen_shortestpath}, and as shown in figure \ref{fig:neighbormask}. 

The naive implementation of utilizing this would be to for each node loop over each neighboring node within a distance $k$, check if $gcd(i,j)=1$, and if so, compute the cost to that node and add it to the $OPEN$ list. This does a lot of uneccesary checks as many of those neighbors will not be selected for expansion because $gcd(i,j)\neq 1$. Instead, the neighborhood mask are precomputed before the search starts and put in an an array. This allows us to instead loop over the array, with exactly as many elements as there is neighbors that will actually be expanded. The pseudocode for the generation of neighborhood masks are given in algorithm \ref{alg:neighborhoodmask}.

\begin{algorithm}
\begin{algorithmic}
\STATE Let $M$ be the neighborhood mask, initially empty.
\FOR {$i := 0\to k$}
    \FOR {$j := 0\to k$}
        \IF {$gcd(i,j) \neq 1$}
            \STATE continue
        \ENDIF
        \STATE $M := M + (i,j)$
        \IF {$ i \neq 0$}
            \STATE $M := M + (-i,j)$
        \ELSIF {$j \neq 0$}
            \STATE $M := M + (i,-j)$
        \ELSIF {$i \neq 0 \land j \neq 0$}
            \STATE $M := M + (-i,-j)$
        \ENDIF
    \ENDFOR
\ENDFOR
\end{algorithmic}
\caption{Pseudocode for constructing the neighborhood mask}
\label{alg:neighborhoodmask}
\end{algorithm}

%Although \cite{roadgen} uses the principles of a standard A* search for generating a road, there are some particularities with this specific implementation

\subsection{Clothoid spline generation}
Figure \ref{fig:clothoid_pair} shows an example of a clothoid pair, where the colors differentiate the pairs.

\subsection{RoadXML generation}


\section{Integration with snow simulator}
\label{sec:impl_snowsim}

\subsection{Scaling of terrain and model}

\subsection{Model loader and format}
The models used for roads and other meshes in the snow simulator is the Wavefront OBJ format, which is a plaintext format containing information about the material used, positions of vertices, texture coordinates, faces and normals. 

\subsection{Other improvements}

\section{USGS DEM converter}
Real-world height maps are often stored in the USGS Digital Elevation Model (DEM) format. Among the users are Kartverket in Norway, who provides digital elevation maps of Norway. There is also a considerable amount of elevation data in the DEM format for the United States, although it has been mostly superceded by the SDTS format, also developed by the USGS\cite{wiki_usgsdem}. However, the snow simulator uses raw 16 bit integer heightmaps, for simplicity. Converting a USGS DEM map to 16 bit RAW takes time, and as such, it was decided that instead of directly supporting DEMs in the snow simulator, the best approach was to create a stand-alone converter from DEM to RAW.


\subsection{Parsing the DEM file format}
USGS DEM is a format in human readable ASCII characters, and the files are segmented into blocks of 1024 bytes. There are three types of records in a DEM file: one A-record, which is the header, contained in one block; multiple B-records, where each B-record store one column of elevation data and one C-record, which stores statistics of errors and accuracy of the data. We are here concerned about the A and B records since these contain the actual data and metadata. 

Each data element in the DEM format is contained within two offsets in a record. For instance, the spatial resolutions are contained 816 bytes into the A-record, and ending at byte 851. This area contains three values, the x, y and z resolution of the DEM. Since the format is so regular, parsing each field is very straight forward. First, read the block from file (1024 bytes), and store it in a string. Then, with Python, this string is easily sliced at the field boundaries and then split into separate elements, and finally each element is parsed as numbers.

For the elevation data in the B-record, the following conversion must be done, in order to map the data to actual heights, just as described in section \ref{sec:back_brecord}.
$$
h_i = ((e_{max}-e_{min})\cdot y_i+ d_y)\cdot res_y \cdot unit
$$
where $d_y$ is the height datum and $e_{max}$ and $e_{min}$ is the maximum and minimum elevation, respectively. $unit$ is the number of meters per unit specified in the A-record; $unit=1$ for meters, or $0.3048$ for feet.

\subsection{Placing elevation data points and cropping}
The DEM file format allows quadrangles that are not square or axis aligned. For instance, a DEM file may describe a heightmap of the shape shown in figure \ref{fig:dem_quadrangle_raw}, or the quadrangle may be rectangular, or many other polygons described by four vertices. The goal is to convert the DEM to a rectangular heightmap that can be used in other applications, like the snow simulator; in other words, the data points from the heightmap must be aligned in a grid, and finally cropped, as shown in figure \ref{fig:dem_quadrangle_processed}. In this figure, the gray box represents the final grid. The points outside of this box are removed in the cropping process.

\begin{figure}[ht]
\centering
\subfloat[Example quadrangle, unprocessed]{
\includegraphics[width=0.4\textwidth]{figure/quadrangle_skewed}
\label{fig:dem_quadrangle_raw}
}
\qquad
\subfloat[Example quadrangle, cropped]{
\includegraphics[width=0.4\textwidth]{figure/quadrangle_cropped}
\label{fig:dem_quadrangle_processed}
}
\caption{USGS DEM quadrangles; the small circles represent elevation data points}
\label{fig:dem_quadrangle}
\end{figure}

The first step of generating the cropped heightmap is to align each column from the B-records in a grid. In order to do this, we first must compute the dimensions of the bounding box of the quadrangle in order to hold all the data points. The number of B-records (width) is given by the A-record, but each B-record may differ in size, and even if they don't, datapoint $i$ from B-record 1 may not correspond to the same vertical position as datapoint $i$ in B-record 2. 

The corners of the quadrangle in world coordinates is described in the A-record (see appendix \ref{app:usgsdem}). Since we know the spacing between points, we can therefore compute the number of rows $m$ as
$$
m = \left\lceil\frac{y_{world,max}-y_{world,min}}{res_y}\right\rceil
$$
where $y_{world,max}$ and $y_{world,min}$ is the maximum and minimum quadrangle y-values in world coordinates, and $res_y$ is the resolution in the $y$ direction in meters. This is illustrated in figure \ref{fig:dem_quadrangle}. Now, after generating a grid of $m\times n$ elements that can hold all datapoints, for each B-record, we compute the starting row as

$$
row_{0,j} = \left\lfloor \frac{y_{0,j}-y_{world,min}}{res_y}\right\rfloor
$$
where $y_{0,j}$ is the y-position in world coordinates of the first data point in the $j$'th B-record. After the first point, all other points come sequentially, so
$$
row_{k,j} = row_{k-1,j} + 1
$$
where $i_{k,j}$ is the row of the $k$'th data point in the $j$'th B-record. 

If the heightmap from the DEM is not rectangular, it must be cropped in order to produce a rectangular map, as illustrated in \ref{fig:dem_quadrangle}; otherwise, we end up with a lot of bogus data points where the DEM does not contain any data. Another consideration is that we want to remove as few {\textit real} data points as possible. For instance, in figure \ref{fig:dem_quadrangle_raw}, in order to create a rectangular map, we may
\begin{enumerate}
\item Crop the left-most and right-most columns, and the two bottom-most rows (removing 23 data points)
\item OR, crop the 8 bottom rows (removing 96 data points)
\item OR, crop the top 7 rows, and bottom 2 rows
\end{enumerate}
or any other combination that produces a rectangular map. Here, number 1 is clearly preferrable. One way of finding the optimal way of cropping is representing this as a search in state space, and find a shortest path through the graph generated by the nodes (state, i.e. the intermediate grid) and the edges (removal of one row or column) with weights equal to the number of real data points being removed. However, this is time consuming, so a simpler method was used, where the row or column with the highest ratio of real data points over the length of the row or column was used. This appears to work very well in practice.

The pseudocode for placing the DEM data points in a grid and outputing a RAW can be seen in algorithm \ref{alg:demtoraw}. Since the parsing itself is trivial (it's simply a string sliceing, splitting and casting operation), this is assumed to be done already.

\begin{algorithm}[ht]
\begin{algorithmic}
\REQUIRE One parsed A-record $A$, and a list of $n$ parsed B-records $B$
\STATE Get $res_y$ and quadrangle vertices from A-record
\STATE $y_{world,min}\gets \mbox{smallest y-coordinate of all quadrangle vertices}$
\STATE $y_{world,max}\gets \mbox{largest y-coordinate of all quadrangle vertices}$
\STATE $m \gets \left\lceil(y_{world,max}-y_{world,min})/res_y\right\rceil$
\STATE $H\gets \mbox{empty $m\times n$ matrix}$
\FORALL{$b \in B$}
    \STATE Get $y_{0,j}$ from $b$
    \STATE $col \gets \mbox{column index of $b$}$
    \STATE $row \gets \left\lfloor (y_{0,j}-y_{world,min})/res_y\right\rfloor$
    \FORALL{elevation $h\in b$}
        \STATE $H(row,col) \gets h$
        \STATE $row \gets row+1$
    \ENDFOR
\ENDFOR
\STATE $x_{min}\gets 0$, $y_{min}\gets 0$
\STATE $x_{max}\gets n$, $y_{max}\gets m$
\WHILE{there are rows or columns left to crop}
    \STATE $n_{left}\gets \mbox{\# of missing data points in the left column}$
    \STATE $n_{right}\gets \mbox{\# of missing data points in the right column}$
    \STATE $n_{top}\gets \mbox{\# of missing data points in the top row}$
    \STATE $n_{bottom}\gets \mbox{\# of missing data points in the bottom row}$
    \STATE $r_{left}\gets n_{left}/(y_{max}-y_{min})$, $r_{right}\gets n_{right}/(y_{max}-y_{min})$
    \STATE $r_{top}\gets n_{top}/(x_{max}-x_{min})$, $r_{bottom}\gets n_{bottom}/(x_{max}-x_{min})$
    \IF{$r_{top}$ is largest}
        \STATE $y_{min} \gets y_{min}+1$
    \ELSIF{$r_{bottom}$ is largest}
        \STATE $y_{max} \gets y_{max}+1$
    \ELSIF{$r_{left}$ is largest}
        \STATE $x_{min} \gets x_{min}+1$
    \ELSIF{$r_{right}$ is largest}
        \STATE $x_{max} \gets x_{max}+1$
    \ENDIF
\ENDWHILE
\STATE Write $H(y_min:y_max, x_min:x_max)$ to file.
\end{algorithmic}
\caption{Complete algorithm for aligning and cropping a USGS DEM}
\label{alg:demtoraw}
\end{algorithm}

